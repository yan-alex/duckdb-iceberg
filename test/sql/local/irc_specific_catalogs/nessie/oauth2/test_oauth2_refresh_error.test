# name: test/sql/local/irc_specific_catalogs/nessie/oauth2/test_oauth2_refresh_error.test
# description: Test OAuth2 error handling when refresh fails (e.g., 401, invalid_grant)
# group: [oauth2]

# NOTE: This test uses the Nessie/Keycloak infrastructure to test refresh failures
# Scenarios tested:
# 1. Refresh token has been revoked (server returns 401 or invalid_grant error)
# 2. Fallback to client_credentials when refresh_token fails

require-env NESSIE_SERVER_AVAILABLE

require avro

require parquet

require iceberg

require httpfs

set ignore_error_messages

statement ok
CALL enable_logging('HTTP');

statement ok
set logging_level='debug';

statement ok
CREATE SECRET storage_secret (
    TYPE S3,
    KEY_ID 'minioadmin',
    SECRET 'minioadmin',
    ENDPOINT '127.0.0.1:9002',
    URL_STYLE 'path',
    USE_SSL 0
);

# Test 1: Automatic fallback to client_credentials when used without refresh_token
# This tests that when no refresh_token is available, the client falls back to
# re-acquiring the token using client_credentials grant

statement ok
ATTACH '' AS error_lake (
    TYPE ICEBERG,
    CLIENT_ID 'client1',
    CLIENT_SECRET 's3cr3t',
    OAUTH2_SCOPE 'catalog sign',
    OAUTH2_SERVER_URI 'http://127.0.0.1:8080/realms/iceberg/protocol/openid-connect/token',
    ENDPOINT 'http://127.0.0.1:19120/iceberg/',
    ACCESS_DELEGATION_MODE 'none'
);

# Initial operation should work
statement ok
show all tables;

statement ok
CALL truncate_duckdb_logs();

# Force expiry to trigger refresh (will use client_credentials since no refresh_token)
statement ok
SET iceberg_test_force_token_expiry=true;

# Should succeed by using client_credentials grant
statement ok
show all tables;

# Verify a token refresh happened
query I
SELECT count(*) >= 1 AS has_refresh FROM duckdb_logs_parsed('HTTP')
WHERE request.type = 'POST' AND request.url LIKE '%token%';
----
true

statement ok
SET iceberg_test_force_token_expiry=false;

statement ok
DETACH error_lake;

# Test 2: Fallback to client_credentials works
statement ok
CREATE SECRET fallback_secret (
    TYPE ICEBERG,
    CLIENT_ID 'client1',
    CLIENT_SECRET 's3cr3t',
    OAUTH2_SCOPE 'catalog sign',
    OAUTH2_SERVER_URI 'http://127.0.0.1:8080/realms/iceberg/protocol/openid-connect/token'
);

statement ok
ATTACH '' AS fallback_lake (
    TYPE ICEBERG,
    SECRET fallback_secret,
    ENDPOINT 'http://127.0.0.1:19120/iceberg/',
    ACCESS_DELEGATION_MODE 'none'
);

# Should work - uses client_credentials grant
statement ok
show all tables;

statement ok
DETACH fallback_lake;

statement ok
DROP SECRET fallback_secret;

statement ok
DROP SECRET storage_secret;
